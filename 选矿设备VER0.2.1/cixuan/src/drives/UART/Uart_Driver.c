/****************************************Copyright (c)**************************************************
**                          大连金德姆电子有限公司
**                                        硬件部
**                                        产品一部 
**                                   http://www.modern.org
**--------------文件信息--------------------------------------------------------------------------------
**文   件   名: I2C_DRIVER
**创   建   人: 黄力国
**最后修改日期: 2004年12月28日
**描        述: μ/COS-II上的LPC2214的通用I2C  的驱动
**--------------历史版本信息----------------------------------------------------------------------------
** 创建人: 黄力国
** 版  本 : v1.0
** 日　期: 2004年12月28日
** 描　述: 原始版本
**
**--------------当前版本修订------------------------------------------------------------------------------
** 修改人: 
** 日　期:
** 描　述:
**
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#include "config.h"
//#include		 "Uart_driver.h"

#define USE485

int        UART0SendBuf[(UART0_SEND_QUEUE_LENGTH + sizeof(int) - 1) / sizeof(int)];
int        UART1SendBuf[(UART1_SEND_QUEUE_LENGTH + sizeof(int) - 1) / sizeof(int)];

int        UART0RcvBuf[(UART0_RCV_QUEUE_LENGTH + sizeof(int) - 1) / sizeof(int)];
int        UART1RcvBuf[(UART1_RCV_QUEUE_LENGTH + sizeof(int) - 1) / sizeof(int)];

// static  OS_EVENT    *Uart0Sem;
//extern      OS_EVENT    *Uart0_Sem;
//extern      OS_EVENT    *Uart1_Sem;


INT8U Com0SndBuf[UART0_SEND_QUEUE_LENGTH];				//串口发送缓冲区
INT8U Com0RcvBuf[UART0_RCV_QUEUE_LENGTH];				//串口接收缓冲区

//INT8U TmpTBuf[UART0_SEND_QUEUE_LENGTH];         //串口发送缓冲区

INT8U Com1SndBuf[UART1_SEND_QUEUE_LENGTH];				//串口发送缓冲区
INT8U Com1RcvBuf[UART1_RCV_QUEUE_LENGTH];               //串口接收缓冲区

extern volatile DEV_STAT DevStat;


/*********************************************************************************************************
** 函数名称: QueueCreate
** 功能描述: 初始化数据队列
** 输　入: Buf      ：为队列分配的存储空间地址
**         SizeOfBuf：为队列分配的存储空间大小（字节）
**         ReadEmpty：为队列读空时处理程序
**         WriteFull：为队列写满时处理程序
** 输　出: NOT_OK:参数错误
**         QUEUE_OK:成功
** 全局变量: 无
** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
**
** 作　者: 陈明计
** 日　期: 2003年7月2日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
uint8 QueueCreate(void *Buf,
				  uint32 SizeOfBuf,
				  uint8 (* ReadEmpty)(),
				  uint8 (* WriteFull)())
{
	DataQueue *Queue;

	ToggleWD();

	if ( Buf != NULL && SizeOfBuf >= (sizeof(DataQueue)) )		  /* 判断参数是否有效 */
	{
		Queue = (DataQueue *)Buf;

		OS_ENTER_CRITICAL();
		/* 初始化结构体数据 */
		Queue->MaxData = (SizeOfBuf - (uint32)(((DataQueue *)0)->Buf)) / 
						 sizeof(QUEUE_DATA_TYPE);				/* 计算队列可以存储的数据数目 */
		Queue->End = Queue->Buf + Queue->MaxData;				/* 计算数据缓冲的结束地址 */
		Queue->Out = Queue->Buf;
		Queue->In = Queue->Buf;
		Queue->NData = 0;
		Queue->ReadEmpty = ReadEmpty;
		Queue->WriteFull = WriteFull;

		OS_EXIT_CRITICAL();

		return QUEUE_OK;
	}
	else
	{
		return NOT_OK;
	}
}


/*********************************************************************************************************
** 函数名称: QueueRead
** 功能描述: 获取队列中的数据
** 输　入: Ret:存储返回的消息的地址
**         Buf:指向队列的指针
** 输　出: NOT_OK     ：参数错误
**         QUEUE_OK   ：收到消息
**         QUEUE_EMPTY：无消息
** 全局变量: 无
** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
**
** 作　者: 陈明计
** 日　期: 2003年7月2日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
uint8 QueueRead(QUEUE_DATA_TYPE *Ret, void *Buf)
{
	uint8 err;
	DataQueue *Queue;

	ToggleWD();

	err = NOT_OK;
	if ( Buf != NULL )											  /* 队列是否有效 */
	{
		/* 有效 */
		Queue = (DataQueue *)Buf;

		OS_ENTER_CRITICAL();

		if ( Queue->NData > 0 )									  /* 队列是否为空 */
		{
			/* 不空         */
			*Ret = Queue->Out[0];								/* 数据出队     */
			Queue->Out++;										/* 调整出队指针 */
			if ( Queue->Out >= Queue->End )
			{
				Queue->Out = Queue->Buf;
			}
			Queue->NData--;										/* 数据减少      */
			err = QUEUE_OK;
		}
		else
		{														/* 空              */
			err = QUEUE_EMPTY;
			if ( Queue->ReadEmpty != NULL )						  /* 调用用户处理函数 */
			{
				err = Queue->ReadEmpty(Ret, Queue);
			}
		}
		OS_EXIT_CRITICAL();
	}
	return err;
}

/*********************************************************************************************************
** 函数名称: QueueWrite
** 功能描述: FIFO方式发送数据
** 输　入: Buf :指向队列的指针
**         Data:消息数据
** 输　出: NOT_OK   :参数错误
**         QUEUE_FULL:队列满
**         QUEUE_OK  :发送成功
** 全局变量: 无
** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
**
** 作　者: 陈明计
** 日　期: 2003年7月2日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#ifndef EN_QUEUE_WRITE
	#define EN_QUEUE_WRITE      0
#endif

#if EN_QUEUE_WRITE > 0
uint8 QueueWrite(void *Buf, QUEUE_DATA_TYPE Data)
{
	uint8 err;
	DataQueue *Queue;

	ToggleWD();

	err = NOT_OK;
	if ( Buf != NULL )													  /* 队列是否有效 */
	{
		Queue = (DataQueue *)Buf;

		OS_ENTER_CRITICAL();

		if ( Queue->NData < Queue->MaxData )							  /* 队列是否满  */
		{
			/* 不满        */
			Queue->In[0] = Data;										/* 数据入队    */
			Queue->In++;												/* 调整入队指针*/
			if ( Queue->In >= Queue->End )
			{
				Queue->In = Queue->Buf;
			}
			Queue->NData++;												/* 数据增加    */
			err = QUEUE_OK;
		}
		else
		{																/* 满           */
			err = QUEUE_FULL;
			if ( Queue->WriteFull != NULL )								  /* 调用用户处理函数 */
			{
				err = Queue->WriteFull(Queue, Data, Q_WRITE_MODE);
			}
		}
		OS_EXIT_CRITICAL();
	}
	return err;
}
#endif

/*********************************************************************************************************
** 函数名称: QueueWriteFront
** 功能描述: LIFO方式发送数据
** 输　入: Buf:指向队列的指针
**         Data:消息数据
** 输　出: QUEUE_FULL:队列满
**         QUEUE_OK:发送成功
** 全局变量: 无
** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
**
** 作　者: 陈明计
** 日　期: 2003年7月2日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#ifndef EN_QUEUE_WRITE_FRONT
	#define EN_QUEUE_WRITE_FRONT    0
#endif

#if EN_QUEUE_WRITE_FRONT > 0

uint8 QueueWriteFront(void *Buf, QUEUE_DATA_TYPE Data)
{
	uint8 err;
	DataQueue *Queue;

	ToggleWD();

	err = NOT_OK;
	if ( Buf != NULL )													  /* 队列是否有效 */
	{
		Queue = (DataQueue *)Buf;

		OS_ENTER_CRITICAL();

		if ( Queue->NData < Queue->MaxData )							  /* 队列是否满  */
		{
			/* 不满 */
			Queue->Out--;												/* 调整出队指针 */
			if ( Queue->Out < Queue->Buf )
			{
				Queue->Out = Queue->End - 1;
			}
			Queue->Out[0] = Data;										/* 数据入队     */
			Queue->NData++;												/* 数据数目增加 */
			err = QUEUE_OK;
		}
		else
		{																/* 满           */
			err = QUEUE_FULL;
			if ( Queue->WriteFull != NULL )								  /* 调用用户处理函数 */
			{
				err = Queue->WriteFull(Queue, Data, Q_WRITE_FRONT_MODE);
			}
		}
		OS_EXIT_CRITICAL();
	}
	return err;
}

#endif

/*********************************************************************************************************
** 函数名称: QueueNData
** 功能描述: 取得队列中数据数
** 输　入: Buf:指向队列的指针
** 输　出: 消息数
** 全局变量: 无
** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
**
** 作　者: 陈明计
** 日　期: 2003年7月2日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#ifndef EN_QUEUE_NDATA
	#define EN_QUEUE_NDATA    0
#endif

#if EN_QUEUE_NDATA > 0

uint16 QueueNData(void *Buf)
{
	uint16 temp;

	ToggleWD();

	temp = 0;													/* 队列无效返回0 */
	if ( Buf != NULL )
	{
		OS_ENTER_CRITICAL();
		temp = ((DataQueue *)Buf)->NData;
		OS_EXIT_CRITICAL();
	}
	return temp;
}

#endif

/*********************************************************************************************************
** 函数名称: QueueSize
** 功能描述: 取得队列总容量
** 输　入: Buf:指向队列的指针
** 输　出: 队列总容量
** 全局变量: 无
** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
**
** 作　者: 陈明计
** 日　期: 2003年7月2日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#ifndef EN_QUEUE_SIZE
	#define EN_QUEUE_SIZE    0
#endif

#if EN_QUEUE_SIZE > 0

uint16 QueueSize(void *Buf)
{
	uint16 temp;

	ToggleWD();

	temp = 0;													/* 队列无效返回0 */
	if ( Buf != NULL )
	{
		OS_ENTER_CRITICAL();
		temp = ((DataQueue *)Buf)->MaxData;
		OS_EXIT_CRITICAL();
	}
	return temp;
}

#endif

/*********************************************************************************************************
** 函数名称: OSQFlush
** 功能描述: 清空队列
** 输　入: Buf:指向队列的指针
** 输　出: 无
** 全局变量: 无
** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
**
** 作　者: 陈明计
** 日　期: 2003年7月2日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#ifndef EN_QUEUE_FLUSH
	#define EN_QUEUE_FLUSH    0
#endif

#if EN_QUEUE_FLUSH > 0

void QueueFlush(void *Buf)
{
	DataQueue *Queue;

	ToggleWD();

	if ( Buf != NULL )												  /* 队列是否有效 */
	{
		/* 有效         */
		Queue = (DataQueue *)Buf;
		OS_ENTER_CRITICAL();
		Queue->Out = Queue->Buf;
		Queue->In = Queue->Buf;
		Queue->NData = 0;											/* 数据数目为0 */
		OS_EXIT_CRITICAL();
	}
}
#endif

/*********************************************************************************************************
** 函数名称: Uart0WriteFull
** 功能描述: 数据队列写满处理程序 
** 输　入: Buf:指向数据队列
**        Data:将要入队的数据
**        Mod: 入队方式
** 输　出:TRUE  :成功
**        FALSE:失败
** 全局变量: 无
** 调用模块: 无
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
uint8 Uart0WriteFull(DataQueue *Buf, QUEUE_DATA_TYPE Data, uint8 Mod)
{
	uint16 temp;

	Mod = Mod;

	ToggleWD();

	temp = QueueSize((void *)Buf);
	while ( temp <= QueueNData((void *)Buf) )		  /* 等待数据队列不满 */
	{
		ToggleWD();
		OSTimeDly(2);
	}
	return QueueWrite((void *)Buf, Data);			/* 数据重新入队 */
}

/*********************************************************************************************************
** 函数名称: UART0Init
** 功能描述: 初始化UART0 
** 输　入: bps：波特率
**
** 输　出:TRUE  :成功
**        FALSE:失败
** 全局变量: Uart0_Sem
** 调用模块: QueueCreate,OSSemCreate
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
uint8 UART0_Init(uint32 bps)
{
	uint16 Fdiv;
	INT8U i;
	INT8U j;

	ToggleWD();

	//OS_ENTER_CRITICAL();
	PINSEL0 = (PINSEL0 & 0xFFFFFFF0) | 0x00000005;	/* 选择管脚为UART0 */

	U0LCR = 0x80;								/* 允许访问分频因子寄存器 */
	Fdiv = (Fpclk / 16) / bps;					/* 设置波特率 */
	U0DLM = Fdiv / 256;                         
	U0DLL = Fdiv % 256;                     
	U0LCR = 0x03;								/* 禁止访问分频因子寄存器 */
	/* 且设置为8,1,n */
	U0IER = 0x05;								/* 允许接收和发送中断 */
//     U0FCR = 0x87;                               /* 初始化FIFO */
	U0FCR = 0x07;                               /* 初始化FIFO 1字节中断  初始化FIFO*/
	for (i=0; i<17; i++)
	{
		j = U0RBR;			//读空FIFO
	}

	(void)QueueCreate((void *)UART0SendBuf, sizeof(UART0SendBuf), NULL, (uint8 (*)())Uart0WriteFull);
	(void)QueueCreate((void *)UART0RcvBuf, sizeof(UART0RcvBuf), NULL, (uint8 (*)())Uart0WriteFull);


//  PINSEL1 = PINSEL1 & (~BIT14);
//  PINSEL1 = PINSEL1 & (~BIT15);		//P0.23 配置成GPIO		485控制脚
//
//  IO0DIR |= BIT23;                //输出
//
//  Set485_0Input();

//  if ( Uart0_Sem != NULL )
//  {
		return TRUE;
//  }
//  else
//  {
//      return FALSE;
//  }
} 

/******************************************************************************
 函数名称：UART0_SetBPS
 功能描述：设置串口0波特率，和奇偶校验方式
 参数描述：
 参数名称： 输入/输出？ 类型		描述
 bps			输入			INT32U		要设置的波特率
 odd_even	输入		INT8U		校验方式：NONE为无，ODD为奇校验，EVEN为偶校验
				
 返  回  值：无
				   
 作 	 者 ：许岩
 日 	 期：2005-04-11
 修改历史：
		日期		修改人		修改描述
		------		---------	-------------
******************************************************************************/
void UART0_SetBPS(INT32U bps, INT8U odd_even)
{
	uint16 Fdiv;

	ToggleWD();

	OS_ENTER_CRITICAL();
	U0LCR = 0x80;								/* 允许访问分频因子寄存器 */
	Fdiv = (Fpclk / 16) / bps;					/* 设置波特率 */
	U0DLM = Fdiv / 256;                         
	U0DLL = Fdiv % 256;

	if ( odd_even == ODD )
		U0LCR = 0x0B;								/* 禁止访问分频因子寄存器 ，奇校验*/
	else if ( odd_even == EVEN )
		U0LCR = 0x1B;								/* 禁止访问分频因子寄存器 ，偶校验*/
	else
		U0LCR = 0x03;								/* 禁止访问分频因子寄存器 ，无奇偶校验*/

	/* 且设置为8,1,n */
	U0IER = 0x05;								/* 允许接收和发送中断 */
//     U0FCR = 0x87;                               /* 初始化FIFO */
	U0FCR = 0x07;								/* 初始化FIFO 1字节中断 */
	OS_EXIT_CRITICAL();
}

/*********************************************************************************************************
** 函数名称: UART0Putch
** 功能描述: 发送一个字节数据
** 输　入: Data：发送的数据数据
** 输　出:无
** 全局变量: 无
** 调用模块: 无
**
** 作　者: 陈明计
** 日　期: 2003年7月4日
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void UART0Putch(uint8 Data)
{
#ifdef USE485
//  ToggleWD();

	Set485_0Output();
	U0THR = Data;
	while( (U0LSR & 0x40) == 0 )          //等待数据发送完毕
	{
		ToggleWD();
	}
	Set485_0Input();

#else

	uint8 temp;

	ToggleWD();

	QueueWrite((void *)UART0SendBuf, Data);			/* 数据入队 */
	OS_ENTER_CRITICAL();
	if ( (U0LSR & 0x00000020) != 0 )
	{												/* UART0发送保持寄存器空 */
		QueueRead(&temp, UART0SendBuf);				/* 发送最初入队的数据 */
		U0THR = temp;
		U0IER = U0IER | 0x02;						/* 允许发送中断 */
	}
	OS_EXIT_CRITICAL();

#endif
} 

/*********************************************************************************************************
** 函数名称: UART0Write
** 功能描述: 发送多个字节数据
** 输　入: Data:发送数据存储位置
**        NByte:发送数据个数
** 输　出:无
** 全局变量: 无
** 调用模块: UART0Putch
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
// void UART0Write(uint8 *Data, uint16 NByte)
// {
//     OS_ENTER_CRITICAL();
//     while ( NByte-- > 0 )
//     {
//         UART0Putch(*Data++);
//     }
//     OS_EXIT_CRITICAL();
// }
void UART0Write(INT8U const * const snd_buf, INT16U const snd_length)
{
	INT16U i = 0;

	ToggleWD();

	OS_ENTER_CRITICAL();
	for (i=0; i<snd_length; i++)
	{
		UART0Putch(snd_buf[i]);
	}
	OS_EXIT_CRITICAL();
} 

///*********************************************************************************************************
//** 函数名称: UART0Getch
//** 功能描述: 接收一个字节
//** 输　入: 无
//** 输　出: 接收到的数据
//** 全局变量: 无
//** 调用模块: 无
//**-------------------------------------------------------------------------------------------------------
//** 修改人: 黄力国
//** 日　期: 2004年12月28日
//**-------------------------------------------------------------------------------------------------------
//** 修改人: 黄力国
//** 日　期: 2004年12月28日
//**------------------------------------------------------------------------------------------------------
//********************************************************************************************************/
//uint8 UART0Getch(void)
//{
//    uint8 err;
//
//    ToggleWD();
//
//    OS_ENTER_CRITICAL();
//    while ( (U0LSR & 0x00000001) == 0 )
//    {                                           /* 没有收到数据 */
//        U0IER = U0IER | 0x01;                   /* 允许接收中断 */
//        OSSemPend(Uart0_Sem, 0, &err);          /* 等待接收数据 */
//    }
//    err = U0RBR;                                /* 读取收到的数据 */
//    OS_EXIT_CRITICAL();
//    return err;
//}

/*********************************************************************************************************
** 函数名称: UART0_Exception
** 功能描述: UART0中断服务程序
** 输　入: 无
**
** 输　出: 无
**         
** 全局变量: 无
** 调用模块: QueueRead,OSSemPost
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void UART0_Exception(void)
{
	uint8 IIR, temp, i;

	ToggleWD();

	VICIntEnClr = (1 << 6) | (1 << 4);
	VICVectAddr = 0;			// 通知中断控制器中断结束
	OS_ENTER_CRITICAL();

	while ( ((IIR = U0IIR) & 0x01) == 0 )
	{													/* 有中断未处理完 */
//      ToggleWD();
		switch ( IIR & 0x0e )
		{
			case 0x02:									/* THRE中断    */
				for ( i = 0; i < UART0_FIFO_LENGTH; i++ ) /* 向发送FIFO填充数据 */
				{
					if ( QueueRead(&temp, UART0SendBuf) == QUEUE_OK )
					{
						U0THR = temp;
					}
					else
					{
						U0IER = U0IER & (~0x02);		/* 队列空，则禁止发送中断 */
					}
				}
				break;
			case 0x04:									/* 接收数据可用 */
//              OSSemPost(Uart0_Sem);                   /* 通知接收任务 */
//              U0IER = U0IER & (~0x01);                /* 禁止接收及字符超时中断 */
				i = U0RBR;
				QueueWrite((void *)UART0RcvBuf, i);			/* 数据入队 */
				break;
			case 0x06:									/* 接收线状态   */
				temp = U0LSR;
				break;
			case 0x0c:									/* 字符超时指示 */
//              OSSemPost(Uart0_Sem);                   /* 通知接收任务 */
//              U0IER = U0IER & (~0x01);                /* 禁止接收及字符超时中断 */
				i = U0RBR;
				QueueWrite((void *)UART0RcvBuf, i);			/* 数据入队 */
				break;
			default :
				break;
		}
	} 
	VICIntEnable = (1 << 6) | (1 << 4);

	OS_EXIT_CRITICAL();
}

/******************************************************************************
 函数名称：CleanCom0Buf
 功能描述：清空串口0缓存
 参数描述：
 参数名称： 输入/输出？ 类型		描述

 返  回  值：无

 作 	 者 ：许岩
 日 	 期：2005-04-11
 修改历史：
		日期		修改人		修改描述
		------		---------	-------------
******************************************************************************/
void CleanCom0Buf(void)
{
	INT8U i = 0;
	volatile INT8U j = 0;

	ToggleWD();

	OS_ENTER_CRITICAL();
	U0FCR = 0x03;								/* 初始化FIFO 1字节中断 清RX FIFO*/
	for ( i=0; i<17; i++ )
	{
		j = U0RBR;			//读空FIFO
	}
	OS_EXIT_CRITICAL();

	QueueFlush(UART0RcvBuf);
}

/******************************************************************************
 函数名称：com0_send_hex
 功能描述：
 参数描述：
 参数名称： 输入/输出？ 类型		描述
 str_to_send	输入	INT8U *		要发送的字符串
 len				输入	INT16U		长度
				
 返  回  值：无
				   
 作 	 者 ：许岩
 日 	 期：2005-04-07
 修改历史：
		日期		修改人		修改描述
		------		---------	-------------
******************************************************************************/
void com0_send_hex(INT8U * str_to_send, INT16U len)
{
	INT16U i = 0;

	ToggleWD();

	for (i=0; i<len; i++)
	{
//      ToggleWD();
		UART0Putch(str_to_send[i]);
	}
}

/*****************************************************************
函数原型：com0_gets
功能描述：串口1接收
参数描述：
参数名称：	输入/输出？	类型		描述
-----------		-----------	------	   	-------
str_got		 输出			INT8U*		得到的字符串
timeout_start输入			INT16U		首字超时，单位mS，0死等
timeout		 输入			INT16U		接收字节间隔超时，单位mS
// endchar   输入			INT8U		提示符

 返  回  值：ok(0)-成功
				 KEY_CANCEL-按退出键了
				 notok(0xFF)-失败，超时
作      者：许岩
日      期：2005-08-20
修改历史：
日期		修改人		修改描述
------		---------	-------------
*****************************************************************/
INT8U com0_gets(INT8U *str_got, INT16U *rcv_len, INT16U timeout_start, INT16U timeout)
{
	INT8U i = 0;
	INT16U len = 0;
	INT16U timeout_cntr = 0;

	ToggleWD();

	//第一个字节
	for(;;)
	{
		if( QueueRead(&i, UART0RcvBuf) == QUEUE_OK )
		{
			str_got[len++] = i;
			break;
		}
		else
		{
			if (timeout_start == 0)
			{
				OSTimeDlyHMSM(0, 0, 0, 20);
			}
			else
			{
				timeout_cntr++;
				if (timeout_cntr > timeout_start / 20)			//超时
				{
					str_got[len] = '\0';
					*rcv_len = len;
					return notok;
				}
				OSTimeDlyHMSM(0, 0, 0, 20);
			}
		}
	}

	//其余字节
	timeout_cntr = 0;
	for(;;)
	{
		if( QueueRead(&i, UART0RcvBuf) == QUEUE_OK )
		{
			str_got[len++] = i;
			timeout_cntr = 0;
		}
		else
		{
			timeout_cntr++;
			if (timeout_cntr > timeout / 20)			//超时
			{
				str_got[len] = '\0';
				*rcv_len = len;
				return ok;
			}
			OSTimeDlyHMSM(0, 0, 0, 20);
		}
	}

}

/*********************************************************************************************************
** 函数名称: Uart1WriteFull
** 功能描述: 数据队列写满处理程序 
** 输　入: Buf:指向数据队列
**        Data:将要入队的数据
**        Mod: 入队方式
** 输　出:TRUE  :成功
**        FALSE:失败
** 全局变量: 无
** 调用模块: 无
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
uint8 Uart1WriteFull(DataQueue *Buf, QUEUE_DATA_TYPE Data, uint8 Mod)
{
	uint16 temp;

	Mod = Mod;

	ToggleWD();

	temp = QueueSize((void *)Buf);
	while ( temp <= QueueNData((void *)Buf) )		  /* 等待数据队列不满 */
	{
		OSTimeDly(2);
	}
	return QueueWrite((void *)Buf, Data);			/* 数据重新入队 */
}

/*********************************************************************************************************
** 函数名称: UART0Init
** 功能描述: 初始化UART0 
** 输　入: bps：波特率
**
** 输　出:TRUE  :成功
**        FALSE:失败
** 全局变量: Uart0_Sem
** 调用模块: QueueCreate,OSSemCreate
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
uint8 UART1_Init(uint32 bps)
{
	uint16 Fdiv;
	INT8U i;
	INT8U j;

	ToggleWD();

	OS_ENTER_CRITICAL();
	PINSEL0 = (PINSEL0 & 0xFFF0FFFF) | 0x00050000;	  /* 选择管脚为UART1 */

	U1LCR = 0x80;								/* 允许访问分频因子寄存器 */
	Fdiv = (Fpclk / 16) / bps;					/* 设置波特率 */
	U1DLM = Fdiv / 256;                         
	U1DLL = Fdiv % 256;                     
	U1LCR = 0x03;                               /* 禁止访问分频因子寄存器 */
//  /* 且设置为8,1,n */
//  U1LCR = 0x2B;	//00101011	使能奇偶校验，奇偶校验位强制为1

	U1IER = 0x05;                               /* 允许接收和发送中断 */
//  U1IER = 0x00;								/* 禁止接收中断 */
//     U1FCR = 0x87;                               /* 初始化FIFO */
	U1FCR = 0x07;								/* 初始化FIFO */
	for (i=0; i<17; i++)
	{
		j = U0RBR;			//读空FIFO
	}

	OS_EXIT_CRITICAL();

	(void)QueueCreate((void *)UART1SendBuf, sizeof(UART1SendBuf), NULL, (uint8 (*)())Uart1WriteFull);
	(void)QueueCreate((void *)UART1RcvBuf, sizeof(UART1RcvBuf), NULL, (uint8 (*)())Uart1WriteFull);

//  PINSEL1 = PINSEL1 & (~BIT16);
//  PINSEL1 = PINSEL1 & (~BIT17);		//P0.24 配置成GPIO		485控制脚
//
//  IO0DIR |= BIT24;                //输出
//
//  Set485_1Input();

	return TRUE;
} 

/*********************************************************************************************************
** 函数名称: UART1Putch
** 功能描述: 发送一个字节数据
** 输　入: Data：发送的数据数据
** 输　出:无
** 全局变量: 无
** 调用模块: 无
**
** 作　者: 陈明计
** 日　期: 2003年7月4日
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void UART1Putch(uint8 Data)
{
#ifdef USE485
//  ToggleWD();

	Set485_1Output();
	U1THR = Data;
	while( (U1LSR & 0x40) == 0 )          //等待数据发送完毕
	{
		ToggleWD();
	}
	Set485_1Input();

#else

	uint8 temp;

	ToggleWD();

	QueueWrite((void *)UART1SendBuf, Data);			/* 数据入队 */
	OS_ENTER_CRITICAL();
	if ( (U1LSR & 0x00000020) != 0 )
	{												/* UART0发送保持寄存器空 */
		QueueRead(&temp, UART1SendBuf);				/* 发送最初入队的数据 */
		U1THR = temp;
		U1IER = U1IER | 0x02;						/* 允许发送中断 */
	}
	OS_EXIT_CRITICAL();

#endif
} 

// /*********************************************************************************************************
// ** 函数名称: UART1PutchPSAM
// ** 功能描述: 发送一个字节数据
// ** 输　入: Data：发送的数据数据
// ** 输　出:无
// ** 全局变量: 无
// ** 调用模块: 无
// **
// ** 作　者: 许岩
// ** 日　期: 2005年10月26日
// **-------------------------------------------------------------------------------------------------------
// ********************************************************************************************************/
// void UART1PutchPSAM(uint8 Data)
// {
// 	U1THR = Data;
// 	while( (U1LSR & 0x40) == 0 )          //等待数据发送完毕
// 		;
// }
//
///*********************************************************************************************************
//** 函数名称: UART0Write
//** 功能描述: 发送多个字节数据
//** 输　入: Data:发送数据存储位置
//**        NByte:发送数据个数
//** 输　出:无
//** 全局变量: 无
//** 调用模块: UART0Putch
//**-------------------------------------------------------------------------------------------------------
//** 修改人: 黄力国
//** 日　期: 2004年12月28日
//**-------------------------------------------------------------------------------------------------------
//** 修改人: 黄力国
//** 日　期: 2004年12月28日
//**------------------------------------------------------------------------------------------------------
//********************************************************************************************************/
//// void UART1Write(uint8 *Data, uint16 NByte)
//// {
////     OS_ENTER_CRITICAL();
////     while ( NByte-- > 0 )
////     {
////         UART1Putch(*Data++);
////     }
////     OS_EXIT_CRITICAL();
//// }
//void UART1Write(INT8U const *const snd_buf, INT16U const snd_length)
//{
//    INT16U i = 0;
//
//    ToggleWD();
//
//    OS_ENTER_CRITICAL();
//    for (i=0; i<snd_length; i++)
//    {
//        UART1Putch(snd_buf[i]);
//    }
//    OS_EXIT_CRITICAL();
//}

// /*********************************************************************************************************
// ** 函数名称: UART1WritePSAM
// ** 功能描述: 发送多个字节数据
// ** 输　入: Data:发送数据存储位置
// **        NByte:发送数据个数
// ** 输　出:无
// ** 全局变量: 无
// ** 调用模块: UART0Putch
// **-------------------------------------------------------------------------------------------------------
// ** 修改人: 许岩
// ** 日　期: 2005年10月26日
// **-------------------------------------------------------------------------------------------------------
// ********************************************************************************************************/
// void UART1WritePSAM(INT8U const *const snd_buf, INT16U const snd_length)
// {
// 	INT16U i = 0;
//
// 	ToggleWD();
//
// 	PSAMbusSelectOut();
//
// 	OS_ENTER_CRITICAL();
// 	for (i=0; i<snd_length; i++)
// 	{
// 		UART1PutchPSAM(snd_buf[i]);
// 	}
// 	OS_EXIT_CRITICAL();
//
// 	PSAMbusSelectIn();
// }

///*********************************************************************************************************
//** 函数名称: UART0Getch
//** 功能描述: 接收一个字节
//** 输　入: 无
//** 输　出: 接收到的数据
//** 全局变量: 无
//** 调用模块: 无
//**-------------------------------------------------------------------------------------------------------
//** 修改人: 黄力国
//** 日　期: 2004年12月28日
//**-------------------------------------------------------------------------------------------------------
//** 修改人: 黄力国
//** 日　期: 2004年12月28日
//**------------------------------------------------------------------------------------------------------
//********************************************************************************************************/
//uint8 UART1Getch(void)
//{
//    uint8 err;
//
//    ToggleWD();
//
//    OS_ENTER_CRITICAL();
//    while ( (U1LSR & 0x00000001) == 0 )
//    {                                           /* 没有收到数据 */
//        U1IER = U1IER | 0x01;                   /* 允许接收中断 */
//        OSSemPend(Uart1_Sem, 0, &err);           /* 等待接收数据 */
//    }
//    err = U1RBR;                                /* 读取收到的数据 */
//    OS_EXIT_CRITICAL();
//    return err;
//}

// /******************************************************************************
//  函数名称：UART1GetchPSAM
//  功能描述：PSAM卡接收函数
//  参数描述：
//  参数名称：	输入/输出？	类型		描述
//  time_out	输入		INT16U		设定超时，time_outx10 ms
//  err			输出		INT8U*		错误状态
//
//  返  回  值：接收到的数
//
//  作      者	：许岩
//  日      期：2004-09-02
//  修改历史：
// 		日期		修改人		修改描述
// 		------		---------	-------------
// ******************************************************************************/
// INT8U UART1GetchPSAM(const INT16U timeout, INT8U * const err)
// {
// //	uint8 err;
// 	INT8U i;
// 	OS_ENTER_CRITICAL();
// 	while ((U1LSR & 0x00000001) == 0)
// 	{                                           /* 没有收到数据 */
// 		U1IER = U1IER | 0x01;                   /* 允许接收中断 */
// 		OSSemPend(Uart1_Sem, timeout, err);           /* 等待接收数据 */
// 		if(*err == OS_TIMEOUT)
// 			break;
// 	}
// 	i = U1RBR;                                /* 读取收到的数据 */
// 	OS_EXIT_CRITICAL();
// 	return i;
// }

/*********************************************************************************************************
** 函数名称: UART0_Exception
** 功能描述: UART0中断服务程序
** 输　入: 无
**
** 输　出: 无
**         
** 全局变量: 无
** 调用模块: QueueRead,OSSemPost
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**-------------------------------------------------------------------------------------------------------
** 修改人: 黄力国
** 日　期: 2004年12月28日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void UART1_Exception(void)
{
	uint8 IIR, temp, i;
//   volatile uint8  j;

	ToggleWD();

	VICIntEnClr = (1 << 7) | (1 << 4);
	VICVectAddr = 0;			// 通知中断控制器中断结束
	OS_ENTER_CRITICAL();
	while ( ((IIR = U1IIR) & 0x01) == 0 )
	{													/* 有中断未处理完 */
//      ToggleWD();
		switch ( IIR & 0x0e )
		{
			case 0x02:									/* THRE中断    */
				for ( i = 0; i < UART0_FIFO_LENGTH; i++ ) /* 向发送FIFO填充数据 */
				{
					if ( QueueRead(&temp, UART1SendBuf) == QUEUE_OK )
					{
						U1THR = temp;
					}
					else
					{
						U1IER = U1IER & (~0x02);		/* 队列空，则禁止发送中断 */
					}
				}
				break;

			case 0x04:									/* 接收数据可用 */
// 				OSSemPost(Uart1_Sem);					 /* 通知接收任务 */
// 				U1IER = U1IER & (~0x01);				/* 禁止接收及字符超时中断 */
// //                 j=U1RBR;
				i = U1RBR;
//              QueueWrite((void *)UART1RcvBuf, i);         /* 数据入队 */
				break;

			case 0x06:									/* 接收线状态   */
				temp = U1LSR;
				break;

			case 0x0c:									/* 字符超时指示 */
// 				OSSemPost(Uart1_Sem);					 /* 通知接收任务 */
// 				U1IER = U1IER & (~0x01);				/* 禁止接收及字符超时中断 */

				i = U1RBR;
//              QueueWrite((void *)UART1RcvBuf, i);         /* 数据入队 */
				break;

			default :
				break;
		}
	} 
	VICIntEnable = (1 << 7) | (1 << 4); 
	OS_EXIT_CRITICAL();
}

/******************************************************************************
 函数名称：BCC_Check
 功能描述：对接收到的数据进行BCC校验
 参数描述：
 参数名称：	输入/输出？	类型		描述
 rcv_buf	输入		const INT8U*		要进行BCC校验的数据缓冲区
 rcvd_len	输入		INT8U		接收到的长度
				
 返  回  值：ok(0)-成功
				 notok(0xFF)-失败(BCC校验错误)
				   
 作      者	：许岩
 日      期：2004-09-02
 修改历史：
		日期		修改人		修改描述
		------		---------	-------------
******************************************************************************/
INT8U BCC_Check(const INT8U *rcv_buf, INT8U rcvd_len)
{
	INT8U i = 0;
	INT8U bcc = 0;

	ToggleWD();

	for(i=0; i<rcvd_len-4; i++)
	{
		bcc ^= rcv_buf[i];
	}

	if ( (rcv_buf[rcvd_len - 3] == ((bcc & 0x0F) + 0x30)) && (rcv_buf[rcvd_len - 4] == (((bcc >> 4) & 0x0F) + 0x30)) )
		return ok;
	else
		return notok;
}

/******************************************************************************
  函数名称：Cal_BCC
  功能描述：对接收到的数据进行BCC校验
  参数描述：
  参数名称：	输入/输出？	类型		描述
  buf		输入		const INT8U*		要进行BCC计算的数据缓冲区
  len		输入		INT16U		长度

  返  回  值：计算出来的BCC值

  作      者	：许岩
  日      期：2004-09-02
  修改历史：
 		日期		修改人		修改描述
 		------		---------	-------------
******************************************************************************/
 INT16U Cal_BCC(const INT8U *buf, INT16U len)
 {
 	INT16U i = 0;
 	INT8U bcc = 0;
 	INT16U result;

 	ToggleWD();

 //     for(i=0; i<len-4; i++)
 	for(i=0; i<len; i++)
 	{
 		bcc ^= buf[i];
 	}

 	result = ((INT16U)((bcc >> 4) + 0x30) << 8) + (INT16U)((bcc & 0x0F) + 0x30);
 	return result;
 }

///******************************************************************************
// 函数名称：ComCreateConnctn
// 功能描述：上层函数，把初始化串口和切换通道集成在一起
// 参数描述：
// 参数名称： 输入/输出？ 类型        描述
// bps        输入            INT32U      要设置的波特率为115200-9600
// com_channel    输入    INT8U   要改为的通道
//
// 返  回  值：ok(0)-成功
//                 notok(0xFF)-失败
//
// 作      者 ：许岩
// 日      期：2004-09-02
// 修改历史：
//        日期        修改人      修改描述
//        ------      ---------   -------------
//******************************************************************************/
//INT8U ComCreateConnctn(INT32U bps, INT8U com_channel)
//{
////  INT8U i = 0;
//
////  ToggleWD();
//
//    if (bps > 115200)               //参数检查
//        return notok;
//    if (bps < 9600)
//        return notok;
//    if ( (com_channel != CHANNL_PSAM_PRI_T) && (com_channel != CHANNL_PSAM_PRI_R)
//         && (com_channel != CHANNL_PSAM_SLV_T) && (com_channel != CHANNL_PSAM_SLV_R)
//         && (com_channel != CHANNL_COM1_TR) && (com_channel != CHANNL_485_TR)
//         && (com_channel != CHANNL_ICCARD_T) && (com_channel != CHANNL_ICCARD_R) )  //com_channel必须是此8种之一
//        return notok;
//
//    //初始化串口波特率和通讯方式是8位还是9位
//    if ( (com_channel == CHANNL_COM1_TR) || (com_channel == CHANNL_485_TR) )
//    {
//        UART1SetBPS(bps, 8);                                                    //数据盒用8位方式
//    }
//    else
//    {
//        UART1SetBPS(bps, 9);                                                    //串口初始化，PSAM卡用9位方式
//    }
//
//    //改变通道
//    ChangeComChannel(com_channel);  //改变当前串口通道
//
//    return ok;
//}

/******************************************************************************
 函数名称：UART1SetBPS
 功能描述：设置UART1的波特率和奇偶校验位
 参数描述：
 参数名称：	输入/输出？	类型		描述
 bps		输入			INT32U		要设置的波特率为115200-9600
 data_lenth	输入		INT8U		长度，＝8八位 ＝9九位 
				
 返  回  值：无
 作      者	：许岩
 日      期：2004-09-02
 修改历史：
		日期		修改人		修改描述
		------		---------	-------------
******************************************************************************/
void UART1SetBPS(INT32U bps, INT8U data_lenth)
{
	INT16U Fdiv;
//     INT8U j;
//     INT8U i = 0;

	ToggleWD();

	OS_ENTER_CRITICAL();

	U1LCR = 0x80;								/* 允许访问分频因子寄存器 */
	Fdiv = (Fpclk / 16) / bps;					/* 设置波特率 */
	U1DLM = Fdiv / 256;                         
	U1DLL = Fdiv % 256;                     

	if ( data_lenth == 9 )
	{
		U1LCR = 0x1B;               //9位数据
	}
	else
	{
		U1LCR = 0x03;                               /* 禁止访问分频因子寄存器 */
	}

	/* 且设置为8,1,n */
//     U1IER = 0x05;                               /* 允许接收和发送中断 */
// //     U1FCR = 0x87;                               /* 初始化FIFO */
//     U1FCR = 0x07;                               /* 初始化FIFO */
//     for (i=0; i<17; i++)
//     {
//         j = U1RBR;          //读空FIFO
//     }

	U1IER = 0x05;                               /* 允许接收和发送中断 */
//     U1IER = 0x00;           //禁止中断
//     U1FCR = 0x00;                                /* 初始化FIFO */
	U1FCR = 0x87;								 /* 初始化FIFO */

	OS_EXIT_CRITICAL();
}

/******************************************************************************
 函数名称：CRC_Check
 功能描述：对接收到的数据进行CRC校验
 参数描述：
 参数名称：	输入/输出？	类型		描述
 rcv_buf	输入		const INT8U*		要进行BCC校验的数据缓冲区
 rcvd_len	输入		INT8U		接收到的长度

 返  回  值：ok(0)-成功
			  notok(0xFF)-失败(BCC校验错误)

 作      者	：许岩
 日      期：2004-09-02
 修改历史：
	 日期		修改人		修改描述
	 ------		---------	-------------
******************************************************************************/
INT8U CRC_Check(const INT8U *rcv_buf, INT16U rcvd_len)
{
	INT16U crc = 0;

	ToggleWD();

	crc = Cal_Crc(rcv_buf, rcvd_len - 6);

	if ( (rcv_buf[rcvd_len - 6] == (INT8U)(crc >> 8)) && (rcv_buf[rcvd_len - 5] == (INT8U)crc) )
	    return ok;
	else
	    return notok;
}


///******************************************************************************
// 函数名称：CRC_Check
// 功能描述：对接收到的数据进行CRC校验
// 参数描述：
// 参数名称： 输入/输出？ 类型        描述
// rcv_buf    输入        const INT8U*        要进行BCC校验的数据缓冲区
// rcvd_len   输入        INT16U      接收到的长度
//
// 返  回  值：ok(0)-成功
//                 notok(0xFF)-失败(BCC校验错误)
//
// 作      者 ：许岩
// 日      期：2004-09-02
// 修改历史：
//        日期        修改人      修改描述
//        ------      ---------   -------------
//******************************************************************************/
//INT8U CRC_Check(const INT8U *rcv_buf, INT16U rcvd_len)
//{
//    INT16U crc = 0;
//    INT16U crc_rcv = 0;
//
//    ToggleWD();
//
//    if (rcvd_len <= 8)
//        return notok;
//
//    crc = Cal_Crc((void *)rcv_buf, rcvd_len - 8);
//
//    crc_rcv = (ascii_to_hex(rcv_buf[rcvd_len - 8]) << 12) | (ascii_to_hex(rcv_buf[rcvd_len - 7]) << 8)
//                    | (ascii_to_hex(rcv_buf[rcvd_len - 6]) << 4) | ascii_to_hex(rcv_buf[rcvd_len - 5]);
//
//
//    if ( crc == crc_rcv)
//        return ok;
//    else
//        return notok;
//}

/******************************************************************************
 函数名称：com1_send
 功能描述：
 参数描述：
 参数名称： 输入/输出？ 类型        描述
 str_to_send    输入            char *      要发送的字符串

 返  回  值：无

 作      者 ：许岩
 日      期：2005-04-07
 修改历史：
		日期        修改人      修改描述
		------      ---------   -------------
******************************************************************************/
void com1_send(char * str_to_send)
{
	INT16U i = 0;

	ToggleWD();

	while ( str_to_send[i] != '\0' )
	{
		ToggleWD();
		UART1Putch(str_to_send[i]);
		i++;
	}

}

/******************************************************************************
 函数名称：com1_send_hex
 功能描述：
 参数描述：
 参数名称： 输入/输出？ 类型        描述
 str_to_send    输入    INT8U *     要发送的字符串
 len                输入    INT16U      长度

 返  回  值：无

 作      者 ：许岩
 日      期：2005-04-07
 修改历史：
		日期        修改人      修改描述
		------      ---------   -------------
******************************************************************************/
void com1_send_hex(INT8U * str_to_send, INT16U len)
{
	INT16U i = 0;

	ToggleWD();

	for (i=0; i<len; i++)
	{
		ToggleWD();
		UART1Putch(str_to_send[i]);
	}
}

///*****************************************************************
//函数原型：com1_gets2
//功能描述：通讯处理
//参数描述：
//参数名称：  输入/输出？ 类型        描述
//-----------     ----------- ------      -------
//str_got     输出            INT8U*      得到的字符串
//timeout     输入            INT16U      超时，单位mS，0死等
//endchar     输入            INT8U       提示符
//
// 返  回  值：ok(0)-成功
//                 KEY_CANCEL-按退出键了
//                 notok(0xFF)-失败，超时
//作      者  ：许岩
//日      期：2005-08-20
//修改历史：
//日期        修改人      修改描述
//------      ---------   -------------
//*****************************************************************/
//INT8U com1_gets2(INT8U *str_got, INT16U *rcv_len, INT16U timeout, INT8U endchar)
//{
//// //   INT16U i = 0;
//// //   INT8U j = 0;
////  INT8U byte_rcvd = 0;
//// //   INT8U buf[20] = {0};
////  INT16U len = 0;
//// //   INT8U key = NO_KEY;
////  INT8U stat = notok;
////
////  for(;;)
////  {
////      ToggleWD();
////
////      byte_rcvd = UART1Getch2(timeout, &stat);
////      if (stat == ok)
////      {
////          str_got[len++] = byte_rcvd;
////          if (len >= COM_BUFFER_SIZE)
////          {
////              len = 0;
////          }
////          if (byte_rcvd == endchar)
////          {
////              str_got[len] = '\0';
////              *rcv_len = len;
////              return ok;              //收到一包
////          }
////      }
////      else if (stat == KEY_CANCEL)
////      {
////          str_got[len] = '\0';
////          *rcv_len = len;
////          return KEY_CANCEL;
////      }
////      else                                //超时
////      {
////          str_got[len] = '\0';
////          *rcv_len = len;
////          return notok;
////      }
////  }
//
//
//
//
//    INT8U i = 0;
//    INT16U len = 0;
//    INT16U timeout_cntr = 0;
//
//    //第一个字节
//    for(;;)
//    {
//        ToggleWD();
//
//        if( QueueRead(&i, UART1RcvBuf) == QUEUE_OK )
//        {
//            str_got[len++] = i;
//
//            timeout_cntr = 0;
//
//            if (i == endchar)
//            {
//                str_got[len] = '\0';
//                *rcv_len = len;
//                return ok;              //收到一包
//            }
//
//        }
//        else
//        {
//            timeout_cntr++;
//            if (timeout_cntr > timeout / 20)            //超时
//            {
//                str_got[len] = '\0';
//                *rcv_len = len;
//                return notok;
//            }
//            OSTimeDlyHMSM(0, 0, 0, 20);
//        }
//
//    }
//
//}
//
///*****************************************************************
//函数原型：UART1Getch2
//功能描述：通讯处理
//参数描述：
//参数名称：  输入/输出？ 类型        描述
//-----------     ----------- ------      -------
//timeout     输入            INT16U      超时，单位mS，0死等
//stat        输出            INT8U*      状态  ok=成功   notok=超时
//
// 返  回  值：读到的数
//作      者  ：许岩
//日      期：2005-08-20
//修改历史：
//日期        修改人      修改描述
//------      ---------   -------------
//*****************************************************************/
//INT8U UART1Getch2(INT16U timeout, INT8U * stat)
//{
////  INT16U i = 0;
////  INT8U rt = 0;
////  INT8U key = NO_KEY;
////
////     OS_ENTER_CRITICAL();
////  for(;;)
////  {
////      if ((U1LSR & 0x00000001) != 0)
////      {
////          rt = U1RBR;                                 /* 读取收到的数据 */
////          *stat = ok;
////          OS_EXIT_CRITICAL();
////          return rt;
////      }
////      else
////      {
////          key = GetKey();
////          if (key == KB_CANCEL)
////          {
////              *stat = KB_CANCEL;
////              return notok;
////          }
////
////          i++;                    //无数据
////          SleepMs(1);
////          if (timeout == 0)
////          {
////          }
////          else
////          {
////              if (i > timeout)
////              {
////                  *stat = notok;
////                  OS_EXIT_CRITICAL();
////                  return notok;
////              }
////          }
////      }
////  }
//
//    INT8U err;
//
//    ToggleWD();
//    if (timeout < 1000 / OS_TICKS_PER_SEC)
//        timeout = 1000 / OS_TICKS_PER_SEC;
//
//    OS_ENTER_CRITICAL();
//    while ( (U1LSR & 0x00000001) == 0 )
//    {                                           /* 没有收到数据 */
//        U1IER = U1IER | 0x01;                   /* 允许接收中断 */
//        OSSemPend(Uart1_Sem, timeout / (1000 / OS_TICKS_PER_SEC), &err);             /* 等待接收数据 */
//        if (err == OS_TIMEOUT)
//        {
//            *stat = notok;
//            return notok;
//        }
//    }
//    err = U1RBR;                                /* 读取收到的数据 */
//    OS_EXIT_CRITICAL();
//
//    *stat = ok;
//    return err;
//}

///******************************************************************************
// 函数名称：CleanCom1Buf
// 功能描述：清空串口1缓存
// 参数描述：
// 参数名称： 输入/输出？ 类型        描述
//
// 返  回  值：无
//
// 作      者 ：许岩
// 日      期：2005-04-11
// 修改历史：
//        日期        修改人      修改描述
//        ------      ---------   -------------
//******************************************************************************/
void CleanCom1Buf(void)
{
    INT8U i = 0;
    volatile INT8U j = 0;

    ToggleWD();

    OS_ENTER_CRITICAL();
    U1FCR = 0x03;                               /* 初始化FIFO 1字节中断 清RX FIFO*/
    for ( i=0; i<17; i++ )
    {
        j = U1RBR;          //读空FIFO
    }
    OS_EXIT_CRITICAL();

//  OSTimeDly(1);
//
//  OS_ENTER_CRITICAL();
//  U1FCR = 0x03;                               /* 初始化FIFO 1字节中断 清RX FIFO*/
//  for ( i=0; i<17; i++ )
//  {
//      j = U1RBR;          //读空FIFO
//  }
//  OS_EXIT_CRITICAL();
//
//  for(i=0; i<17; i++)
//  {
//      (void)UART1Getch2(10, (INT8U *)&j);
//  }
//
//  for(i=0; i<17; i++)
//  {
//      (void)UART1Getch2(10, (INT8U *)&j);
//  }

    QueueFlush(UART1RcvBuf);
}

/*****************************************************************
函数原型：com1_gets
功能描述：串口1接收
参数描述：
参数名称：  输入/输出？ 类型        描述
-----------     ----------- ------      -------
str_got     输出            INT8U*      得到的字符串
timeout_start输入           INT16U      首字超时，单位mS，0死等
timeout     输入            INT16U      接收字节间隔超时，单位mS
// endchar      输入            INT8U       提示符

 返  回  值：ok(0)-成功
				 KEY_CANCEL-按退出键了
				 notok(0xFF)-失败，超时
作      者  ：许岩
日      期：2005-08-20
修改历史：
日期        修改人      修改描述
------      ---------   -------------
*****************************************************************/
INT8U com1_gets(INT8U *str_got, INT16U *rcv_len, INT16U timeout_start, INT16U timeout)
{
	INT8U i = 0;
	INT16U len = 0;
	INT16U timeout_cntr = 0;

	ToggleWD();

	//第一个字节
	for(;;)
	{
		if( QueueRead(&i, UART1RcvBuf) == QUEUE_OK )
		{
			str_got[len++] = i;
			break;
		}
		else
		{
			if (timeout_start == 0)
			{
				OSTimeDlyHMSM(0, 0, 0, 20);
			}
			else
			{
				timeout_cntr++;
				if (timeout_cntr > timeout_start / 20)          //超时
				{
					str_got[len] = '\0';
					*rcv_len = len;
					return notok;
				}
				OSTimeDlyHMSM(0, 0, 0, 20);
			}
		}
	}

	//其余字节
	timeout_cntr = 0;
	for(;;)
	{
		if( QueueRead(&i, UART1RcvBuf) == QUEUE_OK )
		{
			str_got[len++] = i;
			timeout_cntr = 0;
		}
		else
		{
			timeout_cntr++;
			if (timeout_cntr > timeout / 20)            //超时
			{
				str_got[len] = '\0';
				*rcv_len = len;
				return ok;
			}
			OSTimeDlyHMSM(0, 0, 0, 20);
		}
	}

// //   INT16U i = 0;
// //   INT8U j = 0;
//  INT8U byte_rcvd = 0;
// //   INT8U buf[20] = {0};
//  INT16U len = 0;
// //   INT8U key = NO_KEY;
//  INT8U stat = notok;
//
//  byte_rcvd = getch554a2(timeout_start, &stat);
//  if (stat == ok)
//  {
//      str_got[len++] = byte_rcvd;
//      if (len >= COM_RCV_BUF_SIZE)
//      {
//          len = 0;
//      }
//  }
//  else if (stat == KEY_CANCEL)
//  {
//      str_got[len] = '\0';
//      *rcv_len = len;
//      return KEY_CANCEL;
//  }
//  else                                //超时
//  {
//      str_got[len] = '\0';
//      *rcv_len = len;
//      return notok;
//  }
//
//
//
//  for(;;)
//  {
//      ToggleWD();
//
//      byte_rcvd = getch554a2(timeout, &stat);
//      if (stat == ok)
//      {
//          str_got[len++] = byte_rcvd;
//          if (len >= COM_RCV_BUF_SIZE)
//          {
//              len = 0;
//          }
// //           if (byte_rcvd == endchar)
// //           {
// //               str_got[len] = '\0';
// //               *rcv_len = len;
// //               return ok;              //收到一包
// //           }
//      }
//      else if (stat == KEY_CANCEL)
//      {
//          str_got[len] = '\0';
//          *rcv_len = len;
//          return KEY_CANCEL;
//      }
//      else                                //超时
//      {
//          str_got[len] = '\0';
//          *rcv_len = len;
//          return ok;
//      }
//  }

}

///******************************************************************************
// 函数名称：com1_send_str_protocol
// 功能描述：封装协议包头和包尾,发送出去
// 参数描述：
// 参数名称： 输入/输出？ 类型        描述
// str_to_send    输入            char *      要发送的字符串
//
// 返  回  值：无
//
// 作      者 ：许岩
// 日      期：2005-04-07
// 修改历史：
//        日期        修改人      修改描述
//        ------      ---------   -------------
//******************************************************************************/
//void com1_send_str_protocol(char * str_to_send)
//{
//    INT16U i = 0;
//    INT16U crc;
//    INT8S id[9];
//    INT16U len = 0;
////  INT8U buf[20] = {0};
//
//    ToggleWD();
//
//    id[0] = DevStat.id / 100000 + '0';
//    id[1] = (DevStat.id % 100000) / 10000 + '0';
//    id[2] = (DevStat.id % 10000) / 1000 + '0';
//    id[3] = (DevStat.id % 1000) / 100 + '0';
//    id[4] = (DevStat.id % 100) / 10 + '0';
//    id[5] = (DevStat.id % 10) + '0';
//
//    (void)memcpy((void *)&SndBuf[0], "@START", 6);
//    (void)memcpy((void *)&SndBuf[6], (void *)&id[0], 6);
//
//    while ( str_to_send[i] != '\0' )
//    {
//        ToggleWD();
//        SndBuf[12 + i] = str_to_send[i];
//        i++;
//    }
//
//    crc = Cal_Crc((void *)SndBuf, i + 12);
////  SndBuf[14 + i] = (INT8U)(crc >> 8);
////  SndBuf[14 + i + 1] = (INT8U)crc;
//    SndBuf[12 + i] = ascii((INT8U)(crc >> 8) >> 4);
//    SndBuf[12 + i + 1] = ascii((INT8U)(crc >> 8) & 0x0F);
//    SndBuf[12 + i + 2] = ascii((INT8U)crc >> 4);
//    SndBuf[12 + i + 3] = ascii((INT8U)crc & 0x0F);
//
//    (void)memcpy((void *)&SndBuf[12 + i + 4], "END\r", 5);
//
//    len = i + 12 + 4 + 4;
//
////  for ( i=0; i<len; i++ )
////  {
////      com1putch(SndBuf[i]);
////  }
//
//    com1_send_hex((void *)SndBuf, len);
//}
//
///******************************************************************************
// 函数名称：com1_send_str_protocol
// 功能描述：封装协议包头和包尾,发送出去
// 参数描述：
// 参数名称： 输入/输出？ 类型        描述
// str_to_send    输入    INT8U *     要发送的字符串
// len                输入        INT16U      发送长度
//
// 返  回  值：无
//
// 作      者 ：许岩
// 日      期：2005-04-07
// 修改历史：
//        日期        修改人      修改描述
//        ------      ---------   -------------
//******************************************************************************/
//void com1_send_hex_protocol(INT8U * str_to_send, INT16U len)
//{
//    INT16U i = 0;
//    INT16U crc;
//    INT8S id[9];
//    INT16U len_real = 0;
////  INT8U buf[20] = {0};
//
//    ToggleWD();
//
//    id[0] = DevStat.id / 100000 + '0';
//    id[1] = (DevStat.id % 100000) / 10000 + '0';
//    id[2] = (DevStat.id % 10000) / 1000 + '0';
//    id[3] = (DevStat.id % 1000) / 100 + '0';
//    id[4] = (DevStat.id % 100) / 10 + '0';
//    id[5] = (DevStat.id % 10) + '0';
//
//    (void)memcpy((void *)&SndBuf[0], "@START", 6);
//    (void)memcpy((void *)&SndBuf[6], (void *)&id[0], 6);
//
////  while ( str_to_send[i] != '\0' )
////  {
////      ToggleWD();
////      SndBuf[14 + i] = str_to_send[i];
////      i++;
////  }
//    memcpy((void *)&SndBuf[12], str_to_send, len);
//    i += len;
//
//    crc = Cal_Crc((void *)SndBuf, i + 12);
////  SndBuf[14 + i] = (INT8U)(crc >> 8);
////  SndBuf[14 + i + 1] = (INT8U)crc;
//    SndBuf[12 + i] = ascii((INT8U)(crc >> 8) >> 4);
//    SndBuf[12 + i + 1] = ascii((INT8U)(crc >> 8) & 0x0F);
//    SndBuf[12 + i + 2] = ascii((INT8U)crc >> 4);
//    SndBuf[12 + i + 3] = ascii((INT8U)crc & 0x0F);
//
//    (void)memcpy((void *)&SndBuf[12 + i + 4], "END\r", 5);
//
//    len_real = i + 12 + 4 + 4;
//
////  for ( i=0; i<len_real; i++ )
////  {
////      com1putch(SndBuf[i]);
////  }
//
//    com1_send_hex((void *)SndBuf, len_real);
//}
//


/*********************************************************************************************************
**                            End Of File
********************************************************************************************************/

